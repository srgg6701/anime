/***
 * Module Maps
 * Integrates with Google Maps and provides 
 * several interactions needed for Store Locator.
 */
Site.Maps = (function (window, S, out, $) {
    
    /**
     * Internal vars.
     */
    var gm, // google.maps shortcut alias.
        map, // The google.map.Maps instance.
        ds, // The Directions Service.
        dirDisp, // The Directions Renderer.
        geocoder, // The Geo Coder service.
        _markers, _youAreHereWindow, _bounds, _queuedSearch,
        _placedMarkers = 0,
        hasGeoLoc = Modernizr.geolocation, // Detects browser geolocation API capability.
        hasParam = (Site.Common.getParam('mapStore') !== '') ? true : false,
        $btnSearch = $('#free-text-search button.cta');
    /**
     * Vars primarily used for the distributed pickup points.
     */
    var _pickupPointMarkers = [], // Holds the initial info for the distributed pickup points.
        _placedPickupPointMarkers = [], // Holds the placed pickup point google.maps.marker objects, which also are markers that can be triggered by some event. 
        _mapCanvas = null, // Will contain the map canvas. Currently used for the distributed pickup points;
        _oldBounds; // Keeps track whether the map bounds have changed. Currently used for the distributed pickup points.
    
    /**
     * Options that can be set from the outside when initiating a map.
     */
    var _DEFAULTS = {
		secureHost : true, // Fetch API over HTTPS?
        authToken : 'client=gme-dsgretaillimited2', // Key to use in production.
        canvasId : 'google-maps-canvas', // ID of HTML element holding the map.
        lang : { // Should get populated with language strings by IS7.
            addressNotAvailable : 'The address could not be found in ',
            leavingFrom : 'I am driving from..',
            youAreHere : 'You are here.',
            storeInfo : 'Store information',
            drivingDirections : 'Driving directions'
        },
        gestureHandling : 'cooperative', // Suggest to user they need to use two fingers for scroll (mobile only)
        currentSearchTerm : '', 
        currentSearchInput : '',
        directions : false, // Set directions object data to immediately get directions.
        storeMarkers : [], // Will contain stores from the ISML, generated by IS7.
        pickupPointMarkers : [], // Will contain a list of distributed pickup points generated by IS7. Used in the checkout for the distributed pickup point (Bring) shipping method. 
        country : false, // Will get populated with country found in the store array generated by IS7.
        countryCode : '', // Generated by IS7 in the ISML template.
        languageCode : 'en', // Gets overwritten by IS7 in the ISML template.
        storeId : false, // Used to center map on a single store.
        placeMarkersOnLoad : true, // Set to false to prevent store markers to be placed on load.
        defaultZoom : 4, // Default zoom to use when the map loads initially.
        storeZoom : 12, // Zoom to use when centering on a single store.
        geoZoom : 9, // Zoom to use when centering using Geo Coding or Geo Location API.
        maxZoom : null, // Maximum zoom level to use for the map. Null means no limit.
        markerIcon : 'static/default/images/site/' + globals.channelName + '/google-maps-marker-icon.png',
        defaultCenter : { // Last resort. Kind of centering on Europe.
            lat : 55.178868,
            lng : 15.717772
        }
    };
    
    
    // We don't want to tamper with the defaults, so we copy them to this settings var instead.
    var _s = _DEFAULTS;
    
    
    // Custom MarkerClusterer options. 
    var _mcDEFAULTS = {    		
    		imagePath: '', // Should point to static/default/images/common/libs/markererclusterer/, but we'll leave it empty so the default path is used if no argument is supplied.
    		gridSize: 60,
    		minimumClusterSize: 2,    		
    		maxZoom: null,
    		zoomOnClick: true,
    		averageCenter: false,
    		styles: []
    	};
    
    // We don't want to tamper with the defaults, so we copy them to this settings var instead.
    var _mcs = _mcDEFAULTS;
    
    /**
     * Returns a URL which will render a driving directions map on a store page.
     * @param {string} url A store link.
     * @param {string} address A text search address
     * @param {number} lat A search result latitude.
     * @param {number} lng A search result longitude.
     * @returns {string}
     */
    var getDirectionsLink = function (url, address, lat, lng) {

    	if (!url) { return '#'; } // Something went wrong; return a "harmless" URL..

        return url.replace('{{Address}}', address || '')
            .replace('{{SearchLat}}', lat || '')
            .replace('{{SearchLng}}', lng || '');
    };
    
    
    /**
     * Checks whether a value is a float or not.
     * @param {mixed} value The value to test.
     * @returns {boolean}
     */
    var isFloat = function (value) {
    	var temp = /^\-?([0-9]+(\.[0-9]+)?|Infinity)$/.test(value);
    	if (temp && isFinite(Number(value))) { return true; }
    	else { return false; }
    };
    
    
    /**
     * Place all markers found in the storeMarkers array generated by IS7.
     * @param {string} [selectedStoreId=null] Optional store ID to zoom in on.
     */
    var placeMarkers = function (selectedStoreId) {
        out('Placing map markers..');
        
        var storeData, marker, selectedMarker, directionsLink,
            infoWindow = new gm.InfoWindow({}),
            l = _markers.length,
            mcMarkers = [], // Array to hold the store markers for use with the MarkerClusterer.
        	myStore = Site.Geolocation.getMyStore(),
            showStoreName = globals.templateId !== 'storelocator/pagevariation/CC_StoreDetails';
        
        var launchInfoWindow = function(m) {
        	
        	if (typeof m === 'object' && m.hasOwnProperty('infoWindowContent')) {
	            infoWindow.setContent(m.infoWindowContent.replace('{{currentSearchTerm}}', function() {
	            	
	            	return typeof _s.currentSearchInput === 'string' ? _s.currentSearchInput : '';
	            }));
	            infoWindow.open(map, m);
        	}
        	
    	};

        for (var i = 0; i < l; i++) {
            storeData = _markers[i];
            
            // Validate coordinate float values.
            if (!isFloat(storeData.latitude) || !isFloat(storeData.longitude)) {
            	out('Invalid map coordinates at index ' + i + ': ' + storeData.latitude.toString() + ', ' + storeData.longitude.toString(), 'warn');
            }            
            else if(storeData.latitude > 90 || storeData.latitude < -90) {
                out('Invalid latitude at index ' + i + '. Current latitude: ' + storeData.latitude.toString() + '. Latitude should between -90 and 90 degrees', 'warn');             
            }            
            else if(storeData.longitude > 180 || storeData.longitude < -180) {
                out('Invalid longitude at index ' + i + '. Current longitude: ' + storeData.longitude.toString() + '. Longitude should be between -180 and 180 degrees.', 'warn');             
            }
            else {
                if (hasParam) {
                    directionsLink = storeData.StoreLink + '&diLink=true&searchLocation={{Address}}&searchlat={{SearchLat}}&searchlng={{SearchLng}}&storelat=' + storeData.latitude + '&storelng=' + storeData.longitude + '#directions-panel';
                } else {
                    directionsLink = storeData.StoreLink + '?diLink=true&searchLocation={{Address}}&searchlat={{SearchLat}}&searchlng={{SearchLng}}&storelat=' + storeData.latitude + '&storelng=' + storeData.longitude + '#directions-panel';
                }
                storeData.directionsLink = directionsLink;
                _s.country = storeData.country;
    
                marker = new gm.Marker({
                    storeId : storeData.id,                
                    position : new gm.LatLng(storeData.latitude, storeData.longitude),
                    map : map,
                    icon : _s.markerIcon,
                    directionsLink : directionsLink,
                    infoWindowContent : (function (sd) { // Prepare some HTML for this marker's InfoWindow.
                        var html = '<div class="info-window-wrap">',                     
                        	buttonLink = globals.myStore.setURL + '?StoreID=' + storeData.id;
                            if (showStoreName) {
                                buttonLink += '&StoreName=' + sd.name;
                            }
                            else {
                                buttonLink += '&mapStore=' + storeData.id;
                            }
                        	buttonText = globals.myStore.select;
                        	buttonClass = 'set my-store';
                        
                        if (typeof myStore !== 'undefined' && storeData.id === myStore.id) {
                    		buttonLink += '&Remove=true';
                    		buttonText = globals.myStore.unselect;
                    		buttonClass = 'remove my-store';
                    	}
                        
                        html += sd.image ? '<img src="' + sd.image + '?$store_tns$" alt="" class="info-window-image"/>' : '';
                       	html += '<div class="info-window-content">' +
                            (sd.name ? '<span class="info-window-store-name">' + sd.name + '</span>' : '') +
                            (sd.address ? '<span class="info-window-store-address">' + sd.address + '</span>' : '') +
                            ((sd.zip || sd.city) ? '<span class="info-window-store-postal">' + (sd.zip || '') + ' ' + (sd.city || '') + '</span>' : '') +
                            '</div>';
                       	// ECOM-15389 - Added latitude and longitude to button.
                       	html += '<a class="info-window-select-store button highlight el-button normal-btn ' + buttonClass + '"  data-store-latitude="' + sd.latitude + '" data-store-longitude="' + sd.longitude + '"  data-store-name="'+ sd.name +'" data-store-id="'+ storeData.id +'" href="' + buttonLink + '"><span class="el-button-text"><span class="text"><span>' + buttonText + '</span></span></span><svg class="circular" viewBox="26 26 52 52"><circle class="path" cx="52" cy="52" r="25" fill="none" stroke-width="2" stroke-miterlimit="10"></circle></svg></a>';
                        html += sd.StoreLink ? '<a href="' + storeData.StoreLink + '" class="button info-window-store-link el-button normal-btn highlight"><span class="el-button-text"><span class="text"><span>' + _s.lang.storeInfo + '</span></span></span></a>' : '';
                        html += '<form action="' + directionsLink + '" method="get" id="info-window-directions-form" name="info-window-directions-form">' + 
                                '<input placeholder="' + _s.lang.leavingFrom + '" type="text" value="{{currentSearchTerm}}" class="slim info-window-directions-search" id="directions-search-field"/>' + 
                                '<a class="forward" href="#" onclick="$(\'#info-window-directions-form\').trigger(\'submit\');return false;"></a>' + 
                                '<div class="directions-error-label" id="directions-error-label"></div>' + 
                                '</form>';
                        html += '</div>';
                        return html;
                    })(storeData)
                });
                
                mcMarkers.push(marker);
                
                _bounds.extend(marker.position);
                
                gm.event.addListener(marker, 'click', function(event) {
                    launchInfoWindow(this);
                    var thisStoreId = $(this)[0].storeId,
                        myStore = Site.Geolocation.getMyStore(),
                        $infoWindowButton = $(".info-window-wrap .my-store"),
                        href = $infoWindowButton.attr("href");
                    
                    // Update state of my-store-button in infoWindow when open it
                    if (typeof(myStore) !== "undefined") {
                        if (thisStoreId === myStore.id) {
                    	    Site.Geolocation.changeMyStoreButton($infoWindowButton, href, true);
                    	} else {
                    	    Site.Geolocation.changeMyStoreButton($infoWindowButton, href, false);
                    	}
                	}
                });
                
                // Should we center on this store?
                if (selectedStoreId && selectedStoreId === marker.storeId) {
                    selectedMarker = marker;
                }
                
                _placedMarkers++;
            }
        }
        
        if (selectedMarker) { // A specific store was provided, center on it and show its info.
        	
        	// We need to wait for the map tiles to be loaded first, otherwise the positioning will be off.
        	gm.event.addListenerOnce(map, 'tilesloaded', function() {        		
                out('Centering map on store ' + selectedMarker.storeId);
        		map.setZoom(_s.storeZoom);
                gm.event.trigger(selectedMarker, 'click');
                
                // Cluster the stores on the map.
                var markerClusterer = new MarkerClusterer(map, mcMarkers, _mcs);
        	});        	
        } 
        else if (_placedMarkers) { // There are markers on the map, center around them.
            out('Centering map around markers..');
            map.fitBounds(_bounds);
            
            var markerClusterer = new MarkerClusterer(map, mcMarkers, _mcs), // Cluster the stores on the map.
            	geolocationPosition = Site.Geolocation.getPosition(); // Get the users position.             
  
            // Centers the map on the users current location (if set). We have to wait for the map tiles to be loaded first.
            gm.event.addListenerOnce(map, 'tilesloaded', function() {           
	            if(typeof geolocationPosition !== 'undefined'){
	                out('Got geolocationPosition from Site.Geolocation.getPosition(): ' + geolocationPosition.latitude + ", " + geolocationPosition.longitude);
	                map.setCenter(new gm.LatLng(geolocationPosition.latitude, geolocationPosition.longitude));	               
	                map.setZoom(_s.geoZoom);
	            }
	            else {
	            	out('No position available from Site.Geolocation.getPosition()');
	            }
        	});
        }
        else { // No stores! Center on default location. (this should not happen)
        	map.setCenter(new google.maps.LatLng(_s.defaultCenter.lat, _s.defaultCenter.lng));
        	map.setZoom(_s.defaultZoom);
        }
    };
    
    
    /**
     * ECOM-12037. Places a list distributed pickup points on the map.
     * Only used on the delivery page of the checkout. 
     */
    var placePickupPointMarkers = function (pickupPointMarkers) {
        
        var cachedPickupPoints = S.Common.getSessionItem('cachedPickupPoints'),
            marker = {},
            prevSelectedMarker;
          
        // If any pickup points have been cached in sessionStorage, parse them. If that fails, create a new object to store them in.
        cachedPickupPoints = typeof cachedPickupPoints !== 'undefined' ? JSON.parse(cachedPickupPoints) : {};
        geocoder = geocoder || new gm.Geocoder(); 
        
        // Function to place a pickup point marker on the map and set up events.
        var placeMarker = function(pickupPointMarker) {
          
            marker = new gm.Marker({   
                icon : pinSymbol(pickupPointMarker.color),
                position : new gm.LatLng(pickupPointMarker.latitude, pickupPointMarker.longitude),
                title : pickupPointMarker.name,
                id : pickupPointMarker.id + '-bring',
                map : map,
                label : { text: pickupPointMarker.label, color: 'black' }
            });

            _bounds.extend(marker.position);
            
            // If the marker colour is green it's previously been selected.
            if(pickupPointMarker.color === '#82FF00') {
                
                marker.setZIndex(1000);
                prevSelectedMarker = marker;
            }
            
            // On click, set a new (green) colour and reset the colour of any previously selected marker.
            gm.event.addListener(marker, 'click', function(event) {
                var $selectedPickupPoint = $('#' + this.id); 

                this.setIcon(pinSymbol('#82FF00'));
                this.setLabel({text: this.getLabel().text, color: 'black'});
                
                // Trigger a change event on the marker we clicked on and select the corresponding pickup point in the list.
                if(!$selectedPickupPoint.prop('checked')) {
                    $selectedPickupPoint.prop('checked', true).removeClass('hover').change();
                }
                
                // Reset the colour of any previously selected marker.
                if(typeof prevSelectedMarker !== 'undefined' && prevSelectedMarker.id !== this.id) {
                    prevSelectedMarker.setIcon(pinSymbol('#F46A62'));
                    $('#' + prevSelectedMarker.id).removeClass('hover');
                }
                
                prevSelectedMarker = this;
                
                // Pan to the marker if it's outside the map bounds.
                if(!map.getBounds().contains(this.position)) {
                    map.panTo(this.position);
                }                
            });
            
            // Change marker colour on mouseover.
            gm.event.addListener(marker, 'mouseover', function(event) {

                if(!$('#' + this.id).prop('checked')) {
                    this.setIcon(pinSymbol('#11175e'));
                    this.setLabel({text: this.getLabel().text, color: 'white'});
                    this.setZIndex(2000); // Bring marker we hover to front.
                    
                    $('#' + this.id + ':not(:checked)').addClass('hover');
                }
            });

            // Reset marker colour on mouseout.
            gm.event.addListener(marker, 'mouseout', function(event) {

                if(!$('#' + this.id).prop('checked')) {
                    this.setIcon(pinSymbol());
                    this.setLabel({ text: this.getLabel().text, color: 'black' });
                    this.setZIndex(undefined); // Reset to undefined to preserve the z-index order the markers are placed in.
                    
                    $('#' + this.id + ':not(:checked)').removeClass('hover');
                }
            });
            
            _placedPickupPointMarkers.push(marker);
        };
        
        // Iterate through all pickup points and create a new map marker for each.
        for(var i=0; i<pickupPointMarkers.length; i++) (function(i){ 
            var id = pickupPointMarkers[i].id,
                type = pickupPointMarkers[i].type;

            // If the pickup point is in the list of cached pickup points, get latitude and longitude from there.
            if(typeof cachedPickupPoints[type] !== 'undefined' && typeof cachedPickupPoints[type][id] !== 'undefined') {
                pickupPointMarkers[i].latitude = cachedPickupPoints[type][id].latitude;
                pickupPointMarkers[i].longitude = cachedPickupPoints[type][id].longitude;
            }

            // If the pickup point doesn't have latitude and longitude (e.g, the provider is Matkahuolto), geocode the address to get them. 
            if(typeof pickupPointMarkers[i].latitude === 'undefined' && typeof pickupPointMarkers[i].longitude === 'undefined') {
                // Concatenate the full address of the pickup point.
                var fullAddress = pickupPointMarkers[i].address + ' ' + pickupPointMarkers[i].postalCode + ' ' + pickupPointMarkers[i].city;

                // Try to geocode by using the full address.
                geocoder.geocode({'componentRestrictions': { 'country': _s.countryCode }, 'address' : fullAddress}, function(results, status) {
                    
                    if(status === gm.GeocoderStatus.OK) {

                        pickupPointMarkers[i].latitude = results[0].geometry.location.lat();
                        pickupPointMarkers[i].longitude = results[0].geometry.location.lng();

                        if(typeof cachedPickupPoints[type] === 'undefined') {
                            cachedPickupPoints[type] = {};
                        }
                        
                        cachedPickupPoints[type][id] = {'latitude': results[0].geometry.location.lat(), 'longitude': results[0].geometry.location.lng()};

                        // Cache the latitude and longitude of the pickup point in sessionStorage for later use.
                        S.Common.setSessionItem('cachedPickupPoints', JSON.stringify(cachedPickupPoints));

                        placeMarker(pickupPointMarkers[i]);
                        map.fitBounds(_bounds);
                    }
                    else {
                        out('Geocode unsuccessful: ' + status, 'error');
                    }
                });
            }
            else {
                placeMarker(pickupPointMarkers[i]);
            }
        })(i);
        
        // If the bounds have changed (due to e.g a search), update and center the map on them.
        if(!_bounds.equals(_oldBounds)) {
            
            gm.event.addListenerOnce(map, 'bounds_changed', function() {
                map.fitBounds(_bounds);
                
                _oldBounds = _bounds;
            });
        
            map.setCenter(_bounds.getCenter());
        }
        else {
            map.setCenter(map.getCenter());
        }
    };

    /**
     * Trigger a Google maps event on a marker. Currently limited to click, mouseover and mouseout.
     * This function is currently only used for the distributed pickup points, but could be converted into a more general method if needed.
     * @param {string} id The id of the marker, can be anything, but probably the same value as some HTML class or id. Needs to be set on the marker.
     */
    var triggerGmEvent = (function (id) {
        
        /**
         * Triggers an event on a map marker
         * @param {string} id The id of the marker.
         * @param {string} event The event to be triggered.
         */
        var triggerEvent = function (id, event) {            
            var marker;
            
            for(var i=0; i < _placedPickupPointMarkers.length; i++) {
                if(_placedPickupPointMarkers[i].id === id) {
                    marker = _placedPickupPointMarkers[i];
                    break;
                }
            }
            
            if(typeof marker !== 'undefined' && marker !== null) {
                gm.event.trigger(marker, event);
            }            
        };
        
        return {
            click : function (id) {               
                triggerEvent(id, 'click');
            },
            mouseOver : function (id) {   
                triggerEvent(id, 'mouseover');                
            },
            mouseOut : function (id) {                
                triggerEvent(id, 'mouseout');                
            }
        };
    })(this);
    
    
    /**
     * Generates a marker icon from a SVG path.
     * @param {string} color The colour of the marker. Optional. 
     * @returns {google.maps.Symbol}
     */
    var pinSymbol = function (color) {
        return {
            path: 'M 0,0 C -2,-20 -10,-22 -10,-30 A 10,10 0 1,1 10,-30 C 10,-22 2,-20 0,0 z',
            fillColor: color || '#F46A62',            
            fillOpacity: 1,
            strokeColor: '#444',
            strokeWeight: 1,
            scale: 1,                
            labelOrigin: new gm.Point(0,-28)
       };
    };
    
    /**
     * Returns a store marker for a store ID string.
     * @param {string} storeId A store ID as defined in the storeMarkers array generated by IS7.
     * @returns {google.maps.Marker|false} Returns false if no store ID matched.
     */
    var getMarkerByStoreId = function (storeId) {
        var l = _markers.length;
        for (var i = 0; i < l; i++) {
            if (_markers[i].storeId === storeId) {
                return _markers[i];
            }
        }
        return false;
    };
    
    
    /**
     * Returns an array of markers closest to the provided google.maps.LatLng position.
     * @param {google.maps.LatLng} latLng Position from which to get the nearest markers.
     * @param {int} howMany Maximum number of markers to return.
     * @returns {array} Array containing google.maps.Marker objects.
     */
    var getNearestMarkers = function (latLng, howMany) {
        var markerDist,
            markerLatLng,
            l = _markers.length,
            distances = [];
    
        for (var i = 0; i < l; i++) {
            markerLatLng = new gm.LatLng(_markers[i].latitude, _markers[i].longitude);
            markerDist = gm.geometry.spherical.computeDistanceBetween(latLng, markerLatLng);
            distances.push({ dist : Math.floor(markerDist), marker : _markers[i] });
        }

        // Sort and limit the number of elements.
        distances = distances.sort(function (a, b) {
            return a.dist - b.dist;
        }).slice(0, howMany);

        // Only return the actual markers.
        return (function (resultMarkers) {
            for (var i = 0; i < distances.length; i++) {
                resultMarkers.push(distances[i].marker);
            }
            return {
                latLng : latLng,
                resultMarkers : resultMarkers
            };
        })([]);
    };
    
    
    /**
     * Draws travel directions on the map.
     * @param {object} dir Directions object containing coordinates for source and destination locations.
     * @param {google.maps.TravelMode} [travelMode=DRIVING] Set other travel modes, like WALKING, BICYCKLING, TRANSIT etc.
     */
    var drawDirections = function (dir, travelMode) {
        var request;
        
        out('drawDirections');
        
        ds = ds || new gm.DirectionsService();
        dirDisp = dirDisp || new gm.DirectionsRenderer();
        dirDisp.setPanel(document.getElementById("directions-panel"));
        dirDisp.setMap(map);
        travelMode = travelMode || gm.TravelMode.DRIVING;
        
        request = {
            origin : new gm.LatLng(dir.searchLat, dir.searchLng),
            destination : new gm.LatLng(dir.storeLat, dir.storeLng),
            travelMode : travelMode
        };
        
        ds.route(request, function(result, status) {
            if (status === gm.DirectionsStatus.OK) {
                out('Returning directions.');
                dirDisp.setDirections(result);
            }
        });
    };
    
    
    /**
     * Perform a Maps search and update the map accordingly.
     * @param {string} str Search string for a geographical place.
     * @param {maps marker} [directionsMarker=null] Marker to get directions to (optional).
     * @param {int} [numClosestStores=null] If set, will return an array or closest stores.
     * @returns {boolean} Returns false if no valid location was found. Otherwise true or store array.
     */
    var doSearchAction = function (str, numClosestStores, onResultReady) {
        var resultLocation,
            searchTerm = (typeof str === 'string') ? str + ', ' + _s.country
            									   : str;
        
        out("country: " + _s.country);
        
        if (!str) {
            out('doSearchAction: Invalid search string provided.');
            
            // ECOM-15217 Remove loading class on button after action or ajax call finishes
            Site.Common.resetButton($btnSearch);
            return false;
        }
        
        if (geocoder) {
            geocoder = geocoder
        } else if (gm) {
            geocoder = new gm.Geocoder();
        } else {
            gm = google.maps;
            geocoder = new gm.Geocoder();
        }
        
        var geocoderRequest = (typeof searchTerm === 'string') ? { address : searchTerm, language : _s.languageCode, componentRestrictions: { country:_s.countryCode } } 
        											  		   : { location : searchTerm, language : _s.languageCode, region : _s.countryCode };        
        
        out("geocoderRequest: address " + geocoderRequest.address + ", language " + geocoderRequest.language + ", region " + geocoderRequest.region);

        geocoder.geocode(geocoderRequest, function (results, status) {
            
            var res, cTypes;
            
            // ECOM-15217 Remove loading class on button after action or ajax call finishes
            Site.Common.resetButton($btnSearch);
            
            if (status === gm.GeocoderStatus.OK) { // We got a result back.
                res = results[0];
                
                // Make sure that the result is within our country.
                for (var i = 0; i < res.address_components.length; i++) {
                    cTypes = res.address_components[i].types || false;
                    if (cTypes.length) { 
                        // Iterate component types to find out if it's a country.
                        for (var j = 0; j < cTypes.length; j++) {
                            // Here's the country code, does it match our country?
                            if (cTypes[j] === 'country' && res.address_components[i].short_name !== _s.countryCode) {
                            	onResultReady && onResultReady(false);
                                return false;
                            }
                        }
                    }
                }
                resultLocation = res.geometry.location;
                
                map.setCenter(resultLocation);
                map.setZoom(_s.geoZoom);
                _youAreHereWindow.setPosition(resultLocation);
                _youAreHereWindow.open(map);
                _s.currentSearchTerm = searchTerm;
                _s.currentSearchInput = str;

                // Don't fetch closest store, just focus in on the first geo result.
                if (!numClosestStores) {
                	onResultReady && onResultReady(res);
                } else { // Get closest stores and return them.
                	onResultReady && onResultReady(getNearestMarkers(resultLocation, numClosestStores));
                }
               
            } else {
                out('Geocode was not successful for the following reason: ' + status, 'warn');
                onResultReady && onResultReady(false);
                
            }
            
        });        
        return true;
    };
    
    
    /**
     * Helper function for loadMap. Creates the google.maps.Map object
     * and a few other helper objects for later.
     */
    var prepareMap = function () {
        out('Preparing map..');
        
        gm = google.maps; // Just a shortcut alias.
        _markers = _s.storeMarkers;
        _pickupPointMarkers = _s.pickupPointMarkers;
        
        map = map || new gm.Map(document.getElementById(_s.canvasId), {
            zoom: _s.defaultZoom,
            maxZoom : _s.maxZoom,
            center: new gm.LatLng(_s.defaultCenter.lat, _s.defaultCenter.lng),
            mapTypeId: gm.MapTypeId.ROADMAP,
            gestureHandling : 'cooperative'
        });
                
        _bounds = new gm.LatLngBounds();
        
        _youAreHereWindow = new gm.InfoWindow({
            maxWidth : 128,
            content : _s.lang.youAreHere
        });
        
        // Shall we place store markers?
        if (_markers.length && _s.placeMarkersOnLoad) {
            placeMarkers(_s.storeId || false);         
        }
        
        // We are placing pickup points, save and set the Google Maps canvas.
        if(_pickupPointMarkers) {            
            if(_mapCanvas !== null) {
                setMapCanvas('#pickup-point-map-wrap');  
            } else {
                _mapCanvas = document.getElementById(_s.canvasId);
            }
        }
        
        // Shall we place markers for distributed pickup points?
        if(_pickupPointMarkers.length && _s.placeMarkersOnLoad) {
            // Remove any placed pickup point markers from the map.
            // The _eventMarker array currently only contains the placed pickup points from _pickupPointMarkers. 
            // By removing all the pickup point markers from the map we also clear the _eventMarker array.
            // If this is changed in the future, we might need to keep two seperate arrays. One for all markers with events, and one for the placed markers.
            clearMarkers(_placedPickupPointMarkers);
            
            placePickupPointMarkers(_pickupPointMarkers);
        }
        
        // Shall we draw directions to a store?
        if (_s.directions && typeof _s.directions === 'object' 
            && _s.directions.storeLat
            && _s.directions.storeLng
            && _s.directions.searchLat
            && _s.directions.searchLng) {
            drawDirections(_s.directions);
        } 
        else if (_s.storeId) {
            placeMarkers(_s.storeId);
        }
        
        if (_queuedSearch) {
        	out('Performing queued search for: ' + _queuedSearch);
        	doSearchAction(_queuedSearch);
        }
    };
    
    
    /**
     * Loads a Google map based on a set of options.
     * @param {object} opts Refer to the _DEFAULTS constant at the beginning of this file.
     * @param {object} mcOpts Refer to the _mcDEFAULTS constant at the beginning of this file. Used for setting up markerClusterer.
     * @returns {Boolean}
     */
    var loadMap = function (opts, mcOpts) {
        var o;
        out('Map loading for Map.js page');
        // Assemble settings for the map.
        if (opts) {
            for (o in opts) {
                if (_s.hasOwnProperty(o)) {
                    _s[o] = opts[o];
                }
            }
        }
        
        // Assemble settings for the markerclusterer.
        if (mcOpts) {
            for (o in mcOpts) {
                if (_mcs.hasOwnProperty(o)) {
                    _mcs[o] = mcOpts[o];
                }
            }
        }
        
        // If the google.maps object doesn't exist yet, let's load the API async and then try again.
        if (typeof google === 'undefined' || typeof google.maps === 'undefined') {
            out('google.maps not available, fetching async..');
            
            var script = document.createElement("script");
            
        	var mapsHost = _s.secureHost 
        		? "https://maps-api-ssl.google.com" 
				: "http://maps.googleapis.com";
            
            script.src = mapsHost + "/maps/api/js?" + _s.authToken + "&libraries=geometry&sensor=true&language=" + _s.languageCode.toLowerCase() + "&callback=Site.Maps.onApiScriptLoaded";
            
            document.body.appendChild(script);
            return false;
        } else {
            out('Map loaded, prepare overlays..');
            prepareMap();
            return true;
        }

    };
    
    /**
     * Removes any placed pickup point markers from the map.
     * @param {array} markers An array containing all markers that should be removed from the map.
     */
    var clearMarkers = function(markers) {
        while(markers.length) {
            markers.pop().setMap(null);
        }
    };
    
    /**
     * Sets the content of an element with the canvas for the Google Map instance.
     * @param {string} element The element id the map should be inserted into.
     */
    var setMapCanvas = function (element) {
        var $element = $(element);
        
        if($element.length && typeof _mapCanvas !== 'undefined' && _mapCanvas !== null) { 
            $element.html(_mapCanvas);
        }
    };
    
    /**
     * Center map on store.
     * @param {string} storeId to center on
     */
    var centerMap = function(storeId) {
        
        var pos = _markers.map(function(e) { return e.id; }).indexOf(storeId),
            markerLatLng = new gm.LatLng(_markers[pos].latitude, _markers[pos].longitude);
        
        map.panTo(markerLatLng);
    };
    
    
    return {
        init : loadMap,
        loadMap : loadMap,
        centerMap : centerMap,
        getDirectionsLink : getDirectionsLink,
        triggerGmEvent : triggerGmEvent,
        setMapCanvas : setMapCanvas,
        
        /**
         * Callback method used by Google Maps API script.
         */
        onApiScriptLoaded : function () {
            if (google.maps) {
                out('google.maps ready.');
                loadMap();
            } else { // Try again..
                out('onApiScriptLoaded did not receive google.maps', 'warn');
                setTimeout(this.onApiScriptLoaded, 3000);
            }
        },
        
        
        /**
         * Performs a Maps search for the provided search string. Does not return
         * anything, but invokes a callback function.
         * @param {string} searchTerm An address or similar, to search for.
         * @param {int} numClosestStores How many of the closest stores should we get? Can be 0.
         * @param {function} onResult Callback function to invoke when a result has been delivered.
         *          The callback function will receive a results array.
         */
        doFreeTextSearch : function (searchTerm, numClosestStores, onResult) {
            doSearchAction(searchTerm, numClosestStores, onResult);
        },
        
        
        /**
         * @returns {google.map.Map} The Google Map instance.
         */
        getMap : function () {
            return map;
        },
        
        /**
         * Set a search term to search for as soon as the map is loaded.
         * @param {string} str The term to search for.
         */
        queuedSearch : function (str) {
        	_queuedSearch = str;
        },
        
        /**
         * Places an array of pickup point markers on the map.
         */
        placeNewPickupPointMarkers : function(markers) {
            // Remove any previous markers.
            clearMarkers(_placedPickupPointMarkers);
            
            // Reset bounds.
            _bounds = new gm.LatLngBounds();
            
            // Place new markers.
            placePickupPointMarkers(markers);
        }
    };
    
}(this, Site, Site.Common.out, jQuery));
